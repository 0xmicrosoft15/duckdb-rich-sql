
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
// THIS FILE IS GENERATED BY gentpcecode.py, DO NOT EDIT MANUALLY //
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////


#include "tpce_generated.hpp"

using namespace duckdb;
using namespace std;

namespace TPCE {
struct tpce_append_information {
	TableCatalogEntry *table;
	DataChunk chunk;
	ClientContext *context;
};

static void append_value(DataChunk & chunk, size_t index,
                         size_t & column, int32_t value) {
	((int32_t *)chunk.data[column++].data)[index] = value;
}

static void append_bigint(DataChunk & chunk, size_t index,
                          size_t & column, int64_t value) {
	((int64_t *)chunk.data[column++].data)[index] = value;
}

static void append_string(DataChunk & chunk, size_t index,
                          size_t & column, const char *value) {
	chunk.data[column++].SetStringValue(index, value);
}

static void append_double(DataChunk & chunk, size_t index,
                          size_t & column, double value) {
	((double *)chunk.data[column++].data)[index] = value;
}

static void append_bool(DataChunk & chunk, size_t index,
                        size_t & column, bool value) {
	((bool *)chunk.data[column++].data)[index] = value;
}

static void append_timestamp(DataChunk & chunk, size_t index,
                             size_t & column, CDateTime time) {
	((timestamp_t *)chunk.data[column++].data)[index] =
	    0; // Timestamp::FromString(time.ToStr(1));
}

void append_char(DataChunk & chunk, size_t index, size_t & column,
                 char value) {
	char val[2];
	val[0] = value;
	val[1] = '\0';
	append_string(chunk, index, column, val);
}

static void append_to_append_info(tpce_append_information & info) {
	auto &chunk = info.chunk;
	auto &table = info.table;
	if (chunk.column_count == 0) {
		// initalize the chunk
		auto types = table->GetTypes();
		chunk.Initialize(types);
	} else if (chunk.size() >= STANDARD_VECTOR_SIZE) {
		// flush the chunk
		table->storage->Append(*info.context, chunk);
		// have to reset the chunk
		chunk.Reset();
	}
	for (size_t i = 0; i < chunk.column_count; i++) {
		chunk.data[i].count++;
	}
}

template <typename T> class DuckDBBaseLoader : public CBaseLoader<T> {
  protected:
	tpce_append_information info;

  public:
	DuckDBBaseLoader(TableCatalogEntry *table, ClientContext *context) {
		info.table = table;
		info.context = context;
	}

	void FinishLoad() {
		// append the remainder
		info.table->storage->Append(*info.context, info.chunk);
		info.chunk.Reset();
	}
};


class DuckDBSectorLoad : public DuckDBBaseLoader<SECTOR_ROW> {
public:
	DuckDBSectorLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const SECTOR_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_string(chunk, index, column, next_record.SC_ID);
		append_string(chunk, index, column, next_record.SC_NAME);	
	}

};
	
class DuckDBLastTradeLoad : public DuckDBBaseLoader<LAST_TRADE_ROW> {
public:
	DuckDBLastTradeLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const LAST_TRADE_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_string(chunk, index, column, next_record.LT_S_SYMB);
		append_timestamp(chunk, index, column, next_record.LT_DTS);
		append_double(chunk, index, column, next_record.LT_PRICE);
		append_double(chunk, index, column, next_record.LT_OPEN_PRICE);
		append_bigint(chunk, index, column, next_record.LT_VOL);	
	}

};
	
class DuckDBFinancialLoad : public DuckDBBaseLoader<FINANCIAL_ROW> {
public:
	DuckDBFinancialLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const FINANCIAL_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_bigint(chunk, index, column, next_record.FI_CO_ID);
		append_value(chunk, index, column, next_record.FI_YEAR);
		append_value(chunk, index, column, next_record.FI_QTR);
		append_timestamp(chunk, index, column, next_record.FI_QTR_START_DATE);
		append_double(chunk, index, column, next_record.FI_REVENUE);
		append_double(chunk, index, column, next_record.FI_NET_EARN);
		append_double(chunk, index, column, next_record.FI_BASIC_EPS);
		append_double(chunk, index, column, next_record.FI_DILUT_EPS);
		append_double(chunk, index, column, next_record.FI_MARGIN);
		append_double(chunk, index, column, next_record.FI_INVENTORY);
		append_double(chunk, index, column, next_record.FI_ASSETS);
		append_double(chunk, index, column, next_record.FI_LIABILITY);
		append_bigint(chunk, index, column, next_record.FI_OUT_BASIC);
		append_bigint(chunk, index, column, next_record.FI_OUT_DILUT);	
	}

};
	
class DuckDBTradeLoad : public DuckDBBaseLoader<TRADE_ROW> {
public:
	DuckDBTradeLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const TRADE_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_bigint(chunk, index, column, next_record.T_ID);
		append_timestamp(chunk, index, column, next_record.T_DTS);
		append_string(chunk, index, column, next_record.T_ST_ID);
		append_string(chunk, index, column, next_record.T_TT_ID);
		append_bool(chunk, index, column, next_record.T_IS_CASH);
		append_string(chunk, index, column, next_record.T_S_SYMB);
		append_value(chunk, index, column, next_record.T_QTY);
		append_double(chunk, index, column, next_record.T_BID_PRICE);
		append_bigint(chunk, index, column, next_record.T_CA_ID);
		append_string(chunk, index, column, next_record.T_EXEC_NAME);
		append_double(chunk, index, column, next_record.T_TRADE_PRICE);
		append_double(chunk, index, column, next_record.T_CHRG);
		append_double(chunk, index, column, next_record.T_COMM);
		append_double(chunk, index, column, next_record.T_TAX);
		append_bool(chunk, index, column, next_record.T_LIFO);	
	}

};
	
class DuckDBSettlementLoad : public DuckDBBaseLoader<SETTLEMENT_ROW> {
public:
	DuckDBSettlementLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const SETTLEMENT_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_bigint(chunk, index, column, next_record.SE_T_ID);
		append_string(chunk, index, column, next_record.SE_CASH_TYPE);
		append_timestamp(chunk, index, column, next_record.SE_CASH_DUE_DATE);
		append_double(chunk, index, column, next_record.SE_AMT);	
	}

};
	
class DuckDBCommissionRateLoad : public DuckDBBaseLoader<COMMISSION_RATE_ROW> {
public:
	DuckDBCommissionRateLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const COMMISSION_RATE_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_value(chunk, index, column, next_record.CR_C_TIER);
		append_string(chunk, index, column, next_record.CR_TT_ID);
		append_string(chunk, index, column, next_record.CR_EX_ID);
		append_value(chunk, index, column, next_record.CR_FROM_QTY);
		append_value(chunk, index, column, next_record.CR_TO_QTY);
		append_double(chunk, index, column, next_record.CR_RATE);	
	}

};
	
class DuckDBCustomerAccountLoad : public DuckDBBaseLoader<CUSTOMER_ACCOUNT_ROW> {
public:
	DuckDBCustomerAccountLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const CUSTOMER_ACCOUNT_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_bigint(chunk, index, column, next_record.CA_ID);
		append_bigint(chunk, index, column, next_record.CA_B_ID);
		append_bigint(chunk, index, column, next_record.CA_C_ID);
		append_string(chunk, index, column, next_record.CA_NAME);
		append_char(chunk, index, column, next_record.CA_TAX_ST);
		append_double(chunk, index, column, next_record.CA_BAL);	
	}

};
	
class DuckDBCashTransactionLoad : public DuckDBBaseLoader<CASH_TRANSACTION_ROW> {
public:
	DuckDBCashTransactionLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const CASH_TRANSACTION_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_bigint(chunk, index, column, next_record.CT_T_ID);
		append_timestamp(chunk, index, column, next_record.CT_DTS);
		append_double(chunk, index, column, next_record.CT_AMT);
		append_string(chunk, index, column, next_record.CT_NAME);	
	}

};
	
class DuckDBTaxRateLoad : public DuckDBBaseLoader<TAX_RATE_ROW> {
public:
	DuckDBTaxRateLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const TAX_RATE_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_string(chunk, index, column, next_record.TX_ID);
		append_string(chunk, index, column, next_record.TX_NAME);
		append_double(chunk, index, column, next_record.TX_RATE);	
	}

};
	
class DuckDBCustomerTaxrateLoad : public DuckDBBaseLoader<CUSTOMER_TAXRATE_ROW> {
public:
	DuckDBCustomerTaxrateLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const CUSTOMER_TAXRATE_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_string(chunk, index, column, next_record.CX_TX_ID);
		append_bigint(chunk, index, column, next_record.CX_C_ID);	
	}

};
	
class DuckDBNewsXRefLoad : public DuckDBBaseLoader<NEWS_XREF_ROW> {
public:
	DuckDBNewsXRefLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const NEWS_XREF_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_bigint(chunk, index, column, next_record.NX_NI_ID);
		append_bigint(chunk, index, column, next_record.NX_CO_ID);	
	}

};
	
class DuckDBChargeLoad : public DuckDBBaseLoader<CHARGE_ROW> {
public:
	DuckDBChargeLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const CHARGE_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_string(chunk, index, column, next_record.CH_TT_ID);
		append_value(chunk, index, column, next_record.CH_C_TIER);
		append_double(chunk, index, column, next_record.CH_CHRG);	
	}

};
	
class DuckDBTradeTypeLoad : public DuckDBBaseLoader<TRADE_TYPE_ROW> {
public:
	DuckDBTradeTypeLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const TRADE_TYPE_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_string(chunk, index, column, next_record.TT_ID);
		append_string(chunk, index, column, next_record.TT_NAME);
		append_bool(chunk, index, column, next_record.TT_IS_SELL);
		append_bool(chunk, index, column, next_record.TT_IS_MRKT);	
	}

};
	
class DuckDBHoldingLoad : public DuckDBBaseLoader<HOLDING_ROW> {
public:
	DuckDBHoldingLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const HOLDING_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_bigint(chunk, index, column, next_record.H_T_ID);
		append_bigint(chunk, index, column, next_record.H_CA_ID);
		append_string(chunk, index, column, next_record.H_S_SYMB);
		append_timestamp(chunk, index, column, next_record.H_DTS);
		append_double(chunk, index, column, next_record.H_PRICE);
		append_value(chunk, index, column, next_record.H_QTY);	
	}

};
	
class DuckDBDailyMarketLoad : public DuckDBBaseLoader<DAILY_MARKET_ROW> {
public:
	DuckDBDailyMarketLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const DAILY_MARKET_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_timestamp(chunk, index, column, next_record.DM_DATE);
		append_string(chunk, index, column, next_record.DM_S_SYMB);
		append_double(chunk, index, column, next_record.DM_CLOSE);
		append_double(chunk, index, column, next_record.DM_HIGH);
		append_double(chunk, index, column, next_record.DM_LOW);
		append_bigint(chunk, index, column, next_record.DM_VOL);	
	}

};
	
class DuckDBExchangeLoad : public DuckDBBaseLoader<EXCHANGE_ROW> {
public:
	DuckDBExchangeLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const EXCHANGE_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_string(chunk, index, column, next_record.EX_ID);
		append_string(chunk, index, column, next_record.EX_NAME);
		append_value(chunk, index, column, next_record.EX_NUM_SYMB);
		append_value(chunk, index, column, next_record.EX_OPEN);
		append_value(chunk, index, column, next_record.EX_CLOSE);
		append_string(chunk, index, column, next_record.EX_DESC);
		append_bigint(chunk, index, column, next_record.EX_AD_ID);	
	}

};
	
class DuckDBCompanyLoad : public DuckDBBaseLoader<COMPANY_ROW> {
public:
	DuckDBCompanyLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const COMPANY_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_bigint(chunk, index, column, next_record.CO_ID);
		append_string(chunk, index, column, next_record.CO_ST_ID);
		append_string(chunk, index, column, next_record.CO_NAME);
		append_string(chunk, index, column, next_record.CO_IN_ID);
		append_string(chunk, index, column, next_record.CO_SP_RATE);
		append_string(chunk, index, column, next_record.CO_CEO);
		append_bigint(chunk, index, column, next_record.CO_AD_ID);
		append_string(chunk, index, column, next_record.CO_DESC);
		append_timestamp(chunk, index, column, next_record.CO_OPEN_DATE);	
	}

};
	
class DuckDBCompanyCompetitorLoad : public DuckDBBaseLoader<COMPANY_COMPETITOR_ROW> {
public:
	DuckDBCompanyCompetitorLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const COMPANY_COMPETITOR_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_bigint(chunk, index, column, next_record.CP_CO_ID);
		append_bigint(chunk, index, column, next_record.CP_COMP_CO_ID);
		append_string(chunk, index, column, next_record.CP_IN_ID);	
	}

};
	
class DuckDBAccountPermissionLoad : public DuckDBBaseLoader<ACCOUNT_PERMISSION_ROW> {
public:
	DuckDBAccountPermissionLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const ACCOUNT_PERMISSION_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_bigint(chunk, index, column, next_record.AP_CA_ID);
		append_string(chunk, index, column, next_record.AP_ACL);
		append_string(chunk, index, column, next_record.AP_TAX_ID);
		append_string(chunk, index, column, next_record.AP_L_NAME);
		append_string(chunk, index, column, next_record.AP_F_NAME);	
	}

};
	
class DuckDBBrokerLoad : public DuckDBBaseLoader<BROKER_ROW> {
public:
	DuckDBBrokerLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const BROKER_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_bigint(chunk, index, column, next_record.B_ID);
		append_string(chunk, index, column, next_record.B_ST_ID);
		append_string(chunk, index, column, next_record.B_NAME);
		append_value(chunk, index, column, next_record.B_NUM_TRADES);
		append_double(chunk, index, column, next_record.B_COMM_TOTAL);	
	}

};
	
class DuckDBTradeHistoryLoad : public DuckDBBaseLoader<TRADE_HISTORY_ROW> {
public:
	DuckDBTradeHistoryLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const TRADE_HISTORY_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_bigint(chunk, index, column, next_record.TH_T_ID);
		append_timestamp(chunk, index, column, next_record.TH_DTS);
		append_string(chunk, index, column, next_record.TH_ST_ID);	
	}

};
	
class DuckDBWatchItemLoad : public DuckDBBaseLoader<WATCH_ITEM_ROW> {
public:
	DuckDBWatchItemLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const WATCH_ITEM_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_bigint(chunk, index, column, next_record.WI_WL_ID);
		append_string(chunk, index, column, next_record.WI_S_SYMB);	
	}

};
	
class DuckDBHoldingHistoryLoad : public DuckDBBaseLoader<HOLDING_HISTORY_ROW> {
public:
	DuckDBHoldingHistoryLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const HOLDING_HISTORY_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_bigint(chunk, index, column, next_record.HH_H_T_ID);
		append_bigint(chunk, index, column, next_record.HH_T_ID);
		append_value(chunk, index, column, next_record.HH_BEFORE_QTY);
		append_value(chunk, index, column, next_record.HH_AFTER_QTY);	
	}

};
	
class DuckDBAddressLoad : public DuckDBBaseLoader<ADDRESS_ROW> {
public:
	DuckDBAddressLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const ADDRESS_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_bigint(chunk, index, column, next_record.AD_ID);
		append_string(chunk, index, column, next_record.AD_LINE1);
		append_string(chunk, index, column, next_record.AD_LINE2);
		append_string(chunk, index, column, next_record.AD_ZC_CODE);
		append_string(chunk, index, column, next_record.AD_CTRY);	
	}

};
	
class DuckDBNewsItemLoad : public DuckDBBaseLoader<NEWS_ITEM_ROW> {
public:
	DuckDBNewsItemLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const NEWS_ITEM_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_bigint(chunk, index, column, next_record.NI_ID);
		append_string(chunk, index, column, next_record.NI_HEADLINE);
		append_string(chunk, index, column, next_record.NI_SUMMARY);
		append_string(chunk, index, column, next_record.NI_ITEM);
		append_timestamp(chunk, index, column, next_record.NI_DTS);
		append_string(chunk, index, column, next_record.NI_SOURCE);
		append_string(chunk, index, column, next_record.NI_AUTHOR);	
	}

};
	
class DuckDBWatchListLoad : public DuckDBBaseLoader<WATCH_LIST_ROW> {
public:
	DuckDBWatchListLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const WATCH_LIST_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_bigint(chunk, index, column, next_record.WL_ID);
		append_bigint(chunk, index, column, next_record.WL_C_ID);	
	}

};
	
class DuckDBCustomerLoad : public DuckDBBaseLoader<CUSTOMER_ROW> {
public:
	DuckDBCustomerLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const CUSTOMER_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_bigint(chunk, index, column, next_record.C_ID);
		append_string(chunk, index, column, next_record.C_TAX_ID);
		append_string(chunk, index, column, next_record.C_ST_ID);
		append_string(chunk, index, column, next_record.C_L_NAME);
		append_string(chunk, index, column, next_record.C_F_NAME);
		append_string(chunk, index, column, next_record.C_M_NAME);
		append_char(chunk, index, column, next_record.C_GNDR);
		append_char(chunk, index, column, next_record.C_TIER);
		append_timestamp(chunk, index, column, next_record.C_DOB);
		append_bigint(chunk, index, column, next_record.C_AD_ID);
		append_string(chunk, index, column, next_record.C_CTRY_1);
		append_string(chunk, index, column, next_record.C_AREA_1);
		append_string(chunk, index, column, next_record.C_LOCAL_1);
		append_string(chunk, index, column, next_record.C_EXT_1);
		append_string(chunk, index, column, next_record.C_CTRY_2);
		append_string(chunk, index, column, next_record.C_AREA_2);
		append_string(chunk, index, column, next_record.C_LOCAL_2);
		append_string(chunk, index, column, next_record.C_EXT_2);
		append_string(chunk, index, column, next_record.C_CTRY_3);
		append_string(chunk, index, column, next_record.C_AREA_3);
		append_string(chunk, index, column, next_record.C_LOCAL_3);
		append_string(chunk, index, column, next_record.C_EXT_3);
		append_string(chunk, index, column, next_record.C_EMAIL_1);
		append_string(chunk, index, column, next_record.C_EMAIL_2);	
	}

};
	
class DuckDBHoldingSummaryLoad : public DuckDBBaseLoader<HOLDING_SUMMARY_ROW> {
public:
	DuckDBHoldingSummaryLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const HOLDING_SUMMARY_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_bigint(chunk, index, column, next_record.HS_CA_ID);
		append_string(chunk, index, column, next_record.HS_S_SYMB);
		append_value(chunk, index, column, next_record.HS_QTY);	
	}

};
	
class DuckDBStatusTypeLoad : public DuckDBBaseLoader<STATUS_TYPE_ROW> {
public:
	DuckDBStatusTypeLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const STATUS_TYPE_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_string(chunk, index, column, next_record.ST_ID);
		append_string(chunk, index, column, next_record.ST_NAME);	
	}

};
	
class DuckDBIndustryLoad : public DuckDBBaseLoader<INDUSTRY_ROW> {
public:
	DuckDBIndustryLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const INDUSTRY_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_string(chunk, index, column, next_record.IN_ID);
		append_string(chunk, index, column, next_record.IN_NAME);
		append_string(chunk, index, column, next_record.IN_SC_ID);	
	}

};
	
class DuckDBZipCodeLoad : public DuckDBBaseLoader<ZIP_CODE_ROW> {
public:
	DuckDBZipCodeLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const ZIP_CODE_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_string(chunk, index, column, next_record.ZC_CODE);
		append_string(chunk, index, column, next_record.ZC_TOWN);
		append_string(chunk, index, column, next_record.ZC_DIV);	
	}

};
	
class DuckDBTradeRequestLoad : public DuckDBBaseLoader<TRADE_REQUEST_ROW> {
public:
	DuckDBTradeRequestLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const TRADE_REQUEST_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_bigint(chunk, index, column, next_record.TR_T_ID);
		append_string(chunk, index, column, next_record.TR_TT_ID);
		append_string(chunk, index, column, next_record.TR_S_SYMB);
		append_value(chunk, index, column, next_record.TR_QTY);
		append_double(chunk, index, column, next_record.TR_BID_PRICE);
		append_bigint(chunk, index, column, next_record.TR_B_ID);	
	}

};
	
class DuckDBSecurityLoad : public DuckDBBaseLoader<SECURITY_ROW> {
public:
	DuckDBSecurityLoad(TableCatalogEntry *table, ClientContext *context) : 
		DuckDBBaseLoader(table, context) {

	}

	void WriteNextRecord(const SECURITY_ROW &next_record) {
		auto &chunk = info.chunk;
		append_to_append_info(info);
		size_t index = chunk.size() - 1;
		size_t column = 0;

		append_string(chunk, index, column, next_record.S_SYMB);
		append_string(chunk, index, column, next_record.S_ISSUE);
		append_string(chunk, index, column, next_record.S_ST_ID);
		append_string(chunk, index, column, next_record.S_NAME);
		append_string(chunk, index, column, next_record.S_EX_ID);
		append_bigint(chunk, index, column, next_record.S_CO_ID);
		append_bigint(chunk, index, column, next_record.S_NUM_OUT);
		append_timestamp(chunk, index, column, next_record.S_START_DATE);
		append_timestamp(chunk, index, column, next_record.S_EXCH_DATE);
		append_double(chunk, index, column, next_record.S_PE);
		append_double(chunk, index, column, next_record.S_52WK_HIGH);
		append_timestamp(chunk, index, column, next_record.S_52WK_HIGH_DATE);
		append_double(chunk, index, column, next_record.S_52WK_LOW);
		append_timestamp(chunk, index, column, next_record.S_52WK_LOW_DATE);
		append_double(chunk, index, column, next_record.S_DIVIDEND);
		append_double(chunk, index, column, next_record.S_YIELD);	
	}

};
	
CBaseLoader<SECTOR_ROW> *
DuckDBLoaderFactory::CreateSectorLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "sector" + suffix);
	return new DuckDBSectorLoad(table, context);
}

CBaseLoader<LAST_TRADE_ROW> *
DuckDBLoaderFactory::CreateLastTradeLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "last_trade" + suffix);
	return new DuckDBLastTradeLoad(table, context);
}

CBaseLoader<FINANCIAL_ROW> *
DuckDBLoaderFactory::CreateFinancialLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "financial" + suffix);
	return new DuckDBFinancialLoad(table, context);
}

CBaseLoader<TRADE_ROW> *
DuckDBLoaderFactory::CreateTradeLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "trade" + suffix);
	return new DuckDBTradeLoad(table, context);
}

CBaseLoader<SETTLEMENT_ROW> *
DuckDBLoaderFactory::CreateSettlementLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "settlement" + suffix);
	return new DuckDBSettlementLoad(table, context);
}

CBaseLoader<COMMISSION_RATE_ROW> *
DuckDBLoaderFactory::CreateCommissionRateLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "commission_rate" + suffix);
	return new DuckDBCommissionRateLoad(table, context);
}

CBaseLoader<CUSTOMER_ACCOUNT_ROW> *
DuckDBLoaderFactory::CreateCustomerAccountLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "customer_account" + suffix);
	return new DuckDBCustomerAccountLoad(table, context);
}

CBaseLoader<CASH_TRANSACTION_ROW> *
DuckDBLoaderFactory::CreateCashTransactionLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "cash_transaction" + suffix);
	return new DuckDBCashTransactionLoad(table, context);
}

CBaseLoader<TAX_RATE_ROW> *
DuckDBLoaderFactory::CreateTaxRateLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "tax_rate" + suffix);
	return new DuckDBTaxRateLoad(table, context);
}

CBaseLoader<CUSTOMER_TAXRATE_ROW> *
DuckDBLoaderFactory::CreateCustomerTaxrateLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "customer_taxrate" + suffix);
	return new DuckDBCustomerTaxrateLoad(table, context);
}

CBaseLoader<NEWS_XREF_ROW> *
DuckDBLoaderFactory::CreateNewsXRefLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "news_xref" + suffix);
	return new DuckDBNewsXRefLoad(table, context);
}

CBaseLoader<CHARGE_ROW> *
DuckDBLoaderFactory::CreateChargeLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "charge" + suffix);
	return new DuckDBChargeLoad(table, context);
}

CBaseLoader<TRADE_TYPE_ROW> *
DuckDBLoaderFactory::CreateTradeTypeLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "trade_type" + suffix);
	return new DuckDBTradeTypeLoad(table, context);
}

CBaseLoader<HOLDING_ROW> *
DuckDBLoaderFactory::CreateHoldingLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "holding" + suffix);
	return new DuckDBHoldingLoad(table, context);
}

CBaseLoader<DAILY_MARKET_ROW> *
DuckDBLoaderFactory::CreateDailyMarketLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "daily_market" + suffix);
	return new DuckDBDailyMarketLoad(table, context);
}

CBaseLoader<EXCHANGE_ROW> *
DuckDBLoaderFactory::CreateExchangeLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "exchange" + suffix);
	return new DuckDBExchangeLoad(table, context);
}

CBaseLoader<COMPANY_ROW> *
DuckDBLoaderFactory::CreateCompanyLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "company" + suffix);
	return new DuckDBCompanyLoad(table, context);
}

CBaseLoader<COMPANY_COMPETITOR_ROW> *
DuckDBLoaderFactory::CreateCompanyCompetitorLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "company_competitor" + suffix);
	return new DuckDBCompanyCompetitorLoad(table, context);
}

CBaseLoader<ACCOUNT_PERMISSION_ROW> *
DuckDBLoaderFactory::CreateAccountPermissionLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "account_permission" + suffix);
	return new DuckDBAccountPermissionLoad(table, context);
}

CBaseLoader<BROKER_ROW> *
DuckDBLoaderFactory::CreateBrokerLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "broker" + suffix);
	return new DuckDBBrokerLoad(table, context);
}

CBaseLoader<TRADE_HISTORY_ROW> *
DuckDBLoaderFactory::CreateTradeHistoryLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "trade_history" + suffix);
	return new DuckDBTradeHistoryLoad(table, context);
}

CBaseLoader<WATCH_ITEM_ROW> *
DuckDBLoaderFactory::CreateWatchItemLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "watch_item" + suffix);
	return new DuckDBWatchItemLoad(table, context);
}

CBaseLoader<HOLDING_HISTORY_ROW> *
DuckDBLoaderFactory::CreateHoldingHistoryLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "holding_history" + suffix);
	return new DuckDBHoldingHistoryLoad(table, context);
}

CBaseLoader<ADDRESS_ROW> *
DuckDBLoaderFactory::CreateAddressLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "address" + suffix);
	return new DuckDBAddressLoad(table, context);
}

CBaseLoader<NEWS_ITEM_ROW> *
DuckDBLoaderFactory::CreateNewsItemLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "news_item" + suffix);
	return new DuckDBNewsItemLoad(table, context);
}

CBaseLoader<WATCH_LIST_ROW> *
DuckDBLoaderFactory::CreateWatchListLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "watch_list" + suffix);
	return new DuckDBWatchListLoad(table, context);
}

CBaseLoader<CUSTOMER_ROW> *
DuckDBLoaderFactory::CreateCustomerLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "customer" + suffix);
	return new DuckDBCustomerLoad(table, context);
}

CBaseLoader<HOLDING_SUMMARY_ROW> *
DuckDBLoaderFactory::CreateHoldingSummaryLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "holding_summary" + suffix);
	return new DuckDBHoldingSummaryLoad(table, context);
}

CBaseLoader<STATUS_TYPE_ROW> *
DuckDBLoaderFactory::CreateStatusTypeLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "status_type" + suffix);
	return new DuckDBStatusTypeLoad(table, context);
}

CBaseLoader<INDUSTRY_ROW> *
DuckDBLoaderFactory::CreateIndustryLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "industry" + suffix);
	return new DuckDBIndustryLoad(table, context);
}

CBaseLoader<ZIP_CODE_ROW> *
DuckDBLoaderFactory::CreateZipCodeLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "zip_code" + suffix);
	return new DuckDBZipCodeLoad(table, context);
}

CBaseLoader<TRADE_REQUEST_ROW> *
DuckDBLoaderFactory::CreateTradeRequestLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "trade_request" + suffix);
	return new DuckDBTradeRequestLoad(table, context);
}

CBaseLoader<SECURITY_ROW> *
DuckDBLoaderFactory::CreateSecurityLoader() {
	auto table = context->db.catalog.GetTable(context->ActiveTransaction(),
	                                          schema, "security" + suffix);
	return new DuckDBSecurityLoad(table, context);
}

static vector<ColumnDefinition> SectorColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("sc_id", TypeId::VARCHAR),
	    ColumnDefinition("sc_name", TypeId::VARCHAR)};
}

static vector<ColumnDefinition> LastTradeColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("lt_s_symb", TypeId::VARCHAR),
	    ColumnDefinition("lt_dts", TypeId::TIMESTAMP),
	    ColumnDefinition("lt_price", TypeId::DECIMAL),
	    ColumnDefinition("lt_open_price", TypeId::DECIMAL),
	    ColumnDefinition("lt_vol", TypeId::BIGINT)};
}

static vector<ColumnDefinition> FinancialColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("fi_co_id", TypeId::BIGINT),
	    ColumnDefinition("fi_year", TypeId::INTEGER),
	    ColumnDefinition("fi_qtr", TypeId::INTEGER),
	    ColumnDefinition("fi_qtr_start_date", TypeId::TIMESTAMP),
	    ColumnDefinition("fi_revenue", TypeId::DECIMAL),
	    ColumnDefinition("fi_net_earn", TypeId::DECIMAL),
	    ColumnDefinition("fi_basic_eps", TypeId::DECIMAL),
	    ColumnDefinition("fi_dilut_eps", TypeId::DECIMAL),
	    ColumnDefinition("fi_margin", TypeId::DECIMAL),
	    ColumnDefinition("fi_inventory", TypeId::DECIMAL),
	    ColumnDefinition("fi_assets", TypeId::DECIMAL),
	    ColumnDefinition("fi_liability", TypeId::DECIMAL),
	    ColumnDefinition("fi_out_basic", TypeId::BIGINT),
	    ColumnDefinition("fi_out_dilut", TypeId::BIGINT)};
}

static vector<ColumnDefinition> TradeColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("t_id", TypeId::BIGINT),
	    ColumnDefinition("t_dts", TypeId::TIMESTAMP),
	    ColumnDefinition("t_st_id", TypeId::VARCHAR),
	    ColumnDefinition("t_tt_id", TypeId::VARCHAR),
	    ColumnDefinition("t_is_cash", TypeId::BOOLEAN),
	    ColumnDefinition("t_s_symb", TypeId::VARCHAR),
	    ColumnDefinition("t_qty", TypeId::INTEGER),
	    ColumnDefinition("t_bid_price", TypeId::DECIMAL),
	    ColumnDefinition("t_ca_id", TypeId::BIGINT),
	    ColumnDefinition("t_exec_name", TypeId::VARCHAR),
	    ColumnDefinition("t_trade_price", TypeId::DECIMAL),
	    ColumnDefinition("t_chrg", TypeId::DECIMAL),
	    ColumnDefinition("t_comm", TypeId::DECIMAL),
	    ColumnDefinition("t_tax", TypeId::DECIMAL),
	    ColumnDefinition("t_lifo", TypeId::BOOLEAN)};
}

static vector<ColumnDefinition> SettlementColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("se_t_id", TypeId::BIGINT),
	    ColumnDefinition("se_cash_type", TypeId::VARCHAR),
	    ColumnDefinition("se_cash_due_date", TypeId::TIMESTAMP),
	    ColumnDefinition("se_amt", TypeId::DECIMAL)};
}

static vector<ColumnDefinition> CommissionRateColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("cr_c_tier", TypeId::INTEGER),
	    ColumnDefinition("cr_tt_id", TypeId::VARCHAR),
	    ColumnDefinition("cr_ex_id", TypeId::VARCHAR),
	    ColumnDefinition("cr_from_qty", TypeId::INTEGER),
	    ColumnDefinition("cr_to_qty", TypeId::INTEGER),
	    ColumnDefinition("cr_rate", TypeId::DECIMAL)};
}

static vector<ColumnDefinition> CustomerAccountColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("ca_id", TypeId::BIGINT),
	    ColumnDefinition("ca_b_id", TypeId::BIGINT),
	    ColumnDefinition("ca_c_id", TypeId::BIGINT),
	    ColumnDefinition("ca_name", TypeId::VARCHAR),
	    ColumnDefinition("ca_tax_st", TypeId::VARCHAR),
	    ColumnDefinition("ca_bal", TypeId::DECIMAL)};
}

static vector<ColumnDefinition> CashTransactionColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("ct_t_id", TypeId::BIGINT),
	    ColumnDefinition("ct_dts", TypeId::TIMESTAMP),
	    ColumnDefinition("ct_amt", TypeId::DECIMAL),
	    ColumnDefinition("ct_name", TypeId::VARCHAR)};
}

static vector<ColumnDefinition> TaxRateColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("tx_id", TypeId::VARCHAR),
	    ColumnDefinition("tx_name", TypeId::VARCHAR),
	    ColumnDefinition("tx_rate", TypeId::DECIMAL)};
}

static vector<ColumnDefinition> CustomerTaxrateColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("cx_tx_id", TypeId::VARCHAR),
	    ColumnDefinition("cx_c_id", TypeId::BIGINT)};
}

static vector<ColumnDefinition> NewsXrefColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("nx_ni_id", TypeId::BIGINT),
	    ColumnDefinition("nx_co_id", TypeId::BIGINT)};
}

static vector<ColumnDefinition> ChargeColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("ch_tt_id", TypeId::VARCHAR),
	    ColumnDefinition("ch_c_tier", TypeId::INTEGER),
	    ColumnDefinition("ch_chrg", TypeId::DECIMAL)};
}

static vector<ColumnDefinition> TradeTypeColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("tt_id", TypeId::VARCHAR),
	    ColumnDefinition("tt_name", TypeId::VARCHAR),
	    ColumnDefinition("tt_is_sell", TypeId::BOOLEAN),
	    ColumnDefinition("tt_is_mrkt", TypeId::BOOLEAN)};
}

static vector<ColumnDefinition> HoldingColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("h_t_id", TypeId::BIGINT),
	    ColumnDefinition("h_ca_id", TypeId::BIGINT),
	    ColumnDefinition("h_s_symb", TypeId::VARCHAR),
	    ColumnDefinition("h_dts", TypeId::TIMESTAMP),
	    ColumnDefinition("h_price", TypeId::DECIMAL),
	    ColumnDefinition("h_qty", TypeId::INTEGER)};
}

static vector<ColumnDefinition> DailyMarketColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("dm_date", TypeId::TIMESTAMP),
	    ColumnDefinition("dm_s_symb", TypeId::VARCHAR),
	    ColumnDefinition("dm_close", TypeId::DECIMAL),
	    ColumnDefinition("dm_high", TypeId::DECIMAL),
	    ColumnDefinition("dm_low", TypeId::DECIMAL),
	    ColumnDefinition("dm_vol", TypeId::BIGINT)};
}

static vector<ColumnDefinition> ExchangeColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("ex_id", TypeId::VARCHAR),
	    ColumnDefinition("ex_name", TypeId::VARCHAR),
	    ColumnDefinition("ex_num_symb", TypeId::INTEGER),
	    ColumnDefinition("ex_open", TypeId::INTEGER),
	    ColumnDefinition("ex_close", TypeId::INTEGER),
	    ColumnDefinition("ex_desc", TypeId::VARCHAR),
	    ColumnDefinition("ex_ad_id", TypeId::BIGINT)};
}

static vector<ColumnDefinition> CompanyColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("co_id", TypeId::BIGINT),
	    ColumnDefinition("co_st_id", TypeId::VARCHAR),
	    ColumnDefinition("co_name", TypeId::VARCHAR),
	    ColumnDefinition("co_in_id", TypeId::VARCHAR),
	    ColumnDefinition("co_sp_rate", TypeId::VARCHAR),
	    ColumnDefinition("co_ceo", TypeId::VARCHAR),
	    ColumnDefinition("co_ad_id", TypeId::BIGINT),
	    ColumnDefinition("co_desc", TypeId::VARCHAR),
	    ColumnDefinition("co_open_date", TypeId::TIMESTAMP)};
}

static vector<ColumnDefinition> CompanyCompetitorColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("cp_co_id", TypeId::BIGINT),
	    ColumnDefinition("cp_comp_co_id", TypeId::BIGINT),
	    ColumnDefinition("cp_in_id", TypeId::VARCHAR)};
}

static vector<ColumnDefinition> AccountPermissionColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("ap_ca_id", TypeId::BIGINT),
	    ColumnDefinition("ap_acl", TypeId::VARCHAR),
	    ColumnDefinition("ap_tax_id", TypeId::VARCHAR),
	    ColumnDefinition("ap_l_name", TypeId::VARCHAR),
	    ColumnDefinition("ap_f_name", TypeId::VARCHAR)};
}

static vector<ColumnDefinition> BrokerColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("b_id", TypeId::BIGINT),
	    ColumnDefinition("b_st_id", TypeId::VARCHAR),
	    ColumnDefinition("b_name", TypeId::VARCHAR),
	    ColumnDefinition("b_num_trades", TypeId::INTEGER),
	    ColumnDefinition("b_comm_total", TypeId::DECIMAL)};
}

static vector<ColumnDefinition> TradeHistoryColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("th_t_id", TypeId::BIGINT),
	    ColumnDefinition("th_dts", TypeId::TIMESTAMP),
	    ColumnDefinition("th_st_id", TypeId::VARCHAR)};
}

static vector<ColumnDefinition> WatchItemColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("wi_wl_id", TypeId::BIGINT),
	    ColumnDefinition("wi_s_symb", TypeId::VARCHAR)};
}

static vector<ColumnDefinition> HoldingHistoryColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("hh_h_t_id", TypeId::BIGINT),
	    ColumnDefinition("hh_t_id", TypeId::BIGINT),
	    ColumnDefinition("hh_before_qty", TypeId::INTEGER),
	    ColumnDefinition("hh_after_qty", TypeId::INTEGER)};
}

static vector<ColumnDefinition> AddressColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("ad_id", TypeId::BIGINT),
	    ColumnDefinition("ad_line1", TypeId::VARCHAR),
	    ColumnDefinition("ad_line2", TypeId::VARCHAR),
	    ColumnDefinition("ad_zc_code", TypeId::VARCHAR),
	    ColumnDefinition("ad_ctry", TypeId::VARCHAR)};
}

static vector<ColumnDefinition> NewsItemColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("ni_id", TypeId::BIGINT),
	    ColumnDefinition("ni_headline", TypeId::VARCHAR),
	    ColumnDefinition("ni_summary", TypeId::VARCHAR),
	    ColumnDefinition("ni_item", TypeId::VARCHAR),
	    ColumnDefinition("ni_dts", TypeId::TIMESTAMP),
	    ColumnDefinition("ni_source", TypeId::VARCHAR),
	    ColumnDefinition("ni_author", TypeId::VARCHAR)};
}

static vector<ColumnDefinition> WatchListColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("wl_id", TypeId::BIGINT),
	    ColumnDefinition("wl_c_id", TypeId::BIGINT)};
}

static vector<ColumnDefinition> CustomerColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("c_id", TypeId::BIGINT),
	    ColumnDefinition("c_tax_id", TypeId::VARCHAR),
	    ColumnDefinition("c_st_id", TypeId::VARCHAR),
	    ColumnDefinition("c_l_name", TypeId::VARCHAR),
	    ColumnDefinition("c_f_name", TypeId::VARCHAR),
	    ColumnDefinition("c_m_name", TypeId::VARCHAR),
	    ColumnDefinition("c_gndr", TypeId::VARCHAR),
	    ColumnDefinition("c_tier", TypeId::VARCHAR),
	    ColumnDefinition("c_dob", TypeId::TIMESTAMP),
	    ColumnDefinition("c_ad_id", TypeId::BIGINT),
	    ColumnDefinition("c_ctry_1", TypeId::VARCHAR),
	    ColumnDefinition("c_area_1", TypeId::VARCHAR),
	    ColumnDefinition("c_local_1", TypeId::VARCHAR),
	    ColumnDefinition("c_ext_1", TypeId::VARCHAR),
	    ColumnDefinition("c_ctry_2", TypeId::VARCHAR),
	    ColumnDefinition("c_area_2", TypeId::VARCHAR),
	    ColumnDefinition("c_local_2", TypeId::VARCHAR),
	    ColumnDefinition("c_ext_2", TypeId::VARCHAR),
	    ColumnDefinition("c_ctry_3", TypeId::VARCHAR),
	    ColumnDefinition("c_area_3", TypeId::VARCHAR),
	    ColumnDefinition("c_local_3", TypeId::VARCHAR),
	    ColumnDefinition("c_ext_3", TypeId::VARCHAR),
	    ColumnDefinition("c_email_1", TypeId::VARCHAR),
	    ColumnDefinition("c_email_2", TypeId::VARCHAR)};
}

static vector<ColumnDefinition> HoldingSummaryColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("hs_ca_id", TypeId::BIGINT),
	    ColumnDefinition("hs_s_symb", TypeId::VARCHAR),
	    ColumnDefinition("hs_qty", TypeId::INTEGER)};
}

static vector<ColumnDefinition> StatusTypeColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("st_id", TypeId::VARCHAR),
	    ColumnDefinition("st_name", TypeId::VARCHAR)};
}

static vector<ColumnDefinition> IndustryColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("in_id", TypeId::VARCHAR),
	    ColumnDefinition("in_name", TypeId::VARCHAR),
	    ColumnDefinition("in_sc_id", TypeId::VARCHAR)};
}

static vector<ColumnDefinition> ZipCodeColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("zc_code", TypeId::VARCHAR),
	    ColumnDefinition("zc_town", TypeId::VARCHAR),
	    ColumnDefinition("zc_div", TypeId::VARCHAR)};
}

static vector<ColumnDefinition> TradeRequestColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("tr_t_id", TypeId::BIGINT),
	    ColumnDefinition("tr_tt_id", TypeId::VARCHAR),
	    ColumnDefinition("tr_s_symb", TypeId::VARCHAR),
	    ColumnDefinition("tr_qty", TypeId::INTEGER),
	    ColumnDefinition("tr_bid_price", TypeId::DECIMAL),
	    ColumnDefinition("tr_b_id", TypeId::BIGINT)};
}

static vector<ColumnDefinition> SecurityColumns() {
	return vector<ColumnDefinition>{
	    ColumnDefinition("s_symb", TypeId::VARCHAR),
	    ColumnDefinition("s_issue", TypeId::VARCHAR),
	    ColumnDefinition("s_st_id", TypeId::VARCHAR),
	    ColumnDefinition("s_name", TypeId::VARCHAR),
	    ColumnDefinition("s_ex_id", TypeId::VARCHAR),
	    ColumnDefinition("s_co_id", TypeId::BIGINT),
	    ColumnDefinition("s_num_out", TypeId::BIGINT),
	    ColumnDefinition("s_start_date", TypeId::TIMESTAMP),
	    ColumnDefinition("s_exch_date", TypeId::TIMESTAMP),
	    ColumnDefinition("s_pe", TypeId::DECIMAL),
	    ColumnDefinition("s_52wk_high", TypeId::DECIMAL),
	    ColumnDefinition("s_52wk_high_date", TypeId::TIMESTAMP),
	    ColumnDefinition("s_52wk_low", TypeId::DECIMAL),
	    ColumnDefinition("s_52wk_low_date", TypeId::TIMESTAMP),
	    ColumnDefinition("s_dividend", TypeId::DECIMAL),
	    ColumnDefinition("s_yield", TypeId::DECIMAL)};
}

void CreateTPCESchema(duckdb::DuckDB &db, duckdb::Transaction &transaction, std::string &schema, std::string &suffix) {
	CreateTableInformation sector(schema, "sector" + suffix, SectorColumns());
	CreateTableInformation last_trade(schema, "last_trade" + suffix, LastTradeColumns());
	CreateTableInformation financial(schema, "financial" + suffix, FinancialColumns());
	CreateTableInformation trade(schema, "trade" + suffix, TradeColumns());
	CreateTableInformation settlement(schema, "settlement" + suffix, SettlementColumns());
	CreateTableInformation commission_rate(schema, "commission_rate" + suffix, CommissionRateColumns());
	CreateTableInformation customer_account(schema, "customer_account" + suffix, CustomerAccountColumns());
	CreateTableInformation cash_transaction(schema, "cash_transaction" + suffix, CashTransactionColumns());
	CreateTableInformation tax_rate(schema, "tax_rate" + suffix, TaxRateColumns());
	CreateTableInformation customer_taxrate(schema, "customer_taxrate" + suffix, CustomerTaxrateColumns());
	CreateTableInformation news_xref(schema, "news_xref" + suffix, NewsXrefColumns());
	CreateTableInformation charge(schema, "charge" + suffix, ChargeColumns());
	CreateTableInformation trade_type(schema, "trade_type" + suffix, TradeTypeColumns());
	CreateTableInformation holding(schema, "holding" + suffix, HoldingColumns());
	CreateTableInformation daily_market(schema, "daily_market" + suffix, DailyMarketColumns());
	CreateTableInformation exchange(schema, "exchange" + suffix, ExchangeColumns());
	CreateTableInformation company(schema, "company" + suffix, CompanyColumns());
	CreateTableInformation company_competitor(schema, "company_competitor" + suffix, CompanyCompetitorColumns());
	CreateTableInformation account_permission(schema, "account_permission" + suffix, AccountPermissionColumns());
	CreateTableInformation broker(schema, "broker" + suffix, BrokerColumns());
	CreateTableInformation trade_history(schema, "trade_history" + suffix, TradeHistoryColumns());
	CreateTableInformation watch_item(schema, "watch_item" + suffix, WatchItemColumns());
	CreateTableInformation holding_history(schema, "holding_history" + suffix, HoldingHistoryColumns());
	CreateTableInformation address(schema, "address" + suffix, AddressColumns());
	CreateTableInformation news_item(schema, "news_item" + suffix, NewsItemColumns());
	CreateTableInformation watch_list(schema, "watch_list" + suffix, WatchListColumns());
	CreateTableInformation customer(schema, "customer" + suffix, CustomerColumns());
	CreateTableInformation holding_summary(schema, "holding_summary" + suffix, HoldingSummaryColumns());
	CreateTableInformation status_type(schema, "status_type" + suffix, StatusTypeColumns());
	CreateTableInformation industry(schema, "industry" + suffix, IndustryColumns());
	CreateTableInformation zip_code(schema, "zip_code" + suffix, ZipCodeColumns());
	CreateTableInformation trade_request(schema, "trade_request" + suffix, TradeRequestColumns());
	CreateTableInformation security(schema, "security" + suffix, SecurityColumns());
	db.catalog.CreateTable(transaction, &sector);
	db.catalog.CreateTable(transaction, &last_trade);
	db.catalog.CreateTable(transaction, &financial);
	db.catalog.CreateTable(transaction, &trade);
	db.catalog.CreateTable(transaction, &settlement);
	db.catalog.CreateTable(transaction, &commission_rate);
	db.catalog.CreateTable(transaction, &customer_account);
	db.catalog.CreateTable(transaction, &cash_transaction);
	db.catalog.CreateTable(transaction, &tax_rate);
	db.catalog.CreateTable(transaction, &customer_taxrate);
	db.catalog.CreateTable(transaction, &news_xref);
	db.catalog.CreateTable(transaction, &charge);
	db.catalog.CreateTable(transaction, &trade_type);
	db.catalog.CreateTable(transaction, &holding);
	db.catalog.CreateTable(transaction, &daily_market);
	db.catalog.CreateTable(transaction, &exchange);
	db.catalog.CreateTable(transaction, &company);
	db.catalog.CreateTable(transaction, &company_competitor);
	db.catalog.CreateTable(transaction, &account_permission);
	db.catalog.CreateTable(transaction, &broker);
	db.catalog.CreateTable(transaction, &trade_history);
	db.catalog.CreateTable(transaction, &watch_item);
	db.catalog.CreateTable(transaction, &holding_history);
	db.catalog.CreateTable(transaction, &address);
	db.catalog.CreateTable(transaction, &news_item);
	db.catalog.CreateTable(transaction, &watch_list);
	db.catalog.CreateTable(transaction, &customer);
	db.catalog.CreateTable(transaction, &holding_summary);
	db.catalog.CreateTable(transaction, &status_type);
	db.catalog.CreateTable(transaction, &industry);
	db.catalog.CreateTable(transaction, &zip_code);
	db.catalog.CreateTable(transaction, &trade_request);
	db.catalog.CreateTable(transaction, &security);
}

} /* namespace TPCE */
